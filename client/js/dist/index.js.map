{
  "version": 3,
  "sources": ["../node_modules/eventemitter3/index.js", "../node_modules/eventemitter3/index.mjs", "../src/robotics/core.ts", "../src/robotics/producer.ts", "../src/robotics/consumer.ts", "../src/robotics/factory.ts", "../src/video/core.ts", "../src/video/producer.ts", "../src/video/consumer.ts", "../src/video/factory.ts", "../src/index.ts"],
  "sourcesContent": [
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n",
    "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
    "/**\n * Core robotics client for RobotHub TransportServer\n * Base class providing REST API and WebSocket functionality\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type {\n  ParticipantRole,\n  RoomInfo,\n  RoomState,\n  ConnectionInfo,\n  WebSocketMessage,\n  JoinMessage,\n  ListRoomsResponse,\n  CreateRoomResponse,\n  GetRoomResponse,\n  GetRoomStateResponse,\n  DeleteRoomResponse,\n  ClientOptions,\n  ErrorCallback,\n  ConnectedCallback,\n  DisconnectedCallback,\n} from './types.js';\n\nexport class RoboticsClientCore extends EventEmitter {\n  protected baseUrl: string;\n  protected apiBase: string;\n  protected websocket: WebSocket | null = null;\n  protected workspaceId: string | null = null;\n  protected roomId: string | null = null;\n  protected role: ParticipantRole | null = null;\n  protected participantId: string | null = null;\n  protected connected = false;\n  protected options: ClientOptions;\n\n  // Event callbacks\n  protected onErrorCallback: ErrorCallback | null = null;\n  protected onConnectedCallback: ConnectedCallback | null = null;\n  protected onDisconnectedCallback: DisconnectedCallback | null = null;\n\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super();\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n    this.apiBase = `${this.baseUrl}/robotics`;\n    this.options = {\n      timeout: 5000,\n      reconnect_attempts: 3,\n      heartbeat_interval: 30000,\n      ...options,\n    };\n  }\n\n  // ============= REST API METHODS =============\n\n  async listRooms(workspaceId: string): Promise<RoomInfo[]> {\n    const response = await this.fetchApi<ListRoomsResponse>(`/workspaces/${workspaceId}/rooms`);\n    return response.rooms;\n  }\n\n  async createRoom(workspaceId?: string, roomId?: string): Promise<{ workspaceId: string; roomId: string }> {\n    // Generate workspace ID if not provided\n    const finalWorkspaceId = workspaceId || this.generateWorkspaceId();\n    \n    const payload = roomId ? { room_id: roomId, workspace_id: finalWorkspaceId } : { workspace_id: finalWorkspaceId };\n    const response = await this.fetchApi<CreateRoomResponse>(`/workspaces/${finalWorkspaceId}/rooms`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n    });\n    return { workspaceId: response.workspace_id, roomId: response.room_id };\n  }\n\n  async deleteRoom(workspaceId: string, roomId: string): Promise<boolean> {\n    try {\n      const response = await this.fetchApi<DeleteRoomResponse>(`/workspaces/${workspaceId}/rooms/${roomId}`, {\n        method: 'DELETE',\n      });\n      return response.success;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('404')) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  async getRoomState(workspaceId: string, roomId: string): Promise<RoomState> {\n    const response = await this.fetchApi<GetRoomStateResponse>(`/workspaces/${workspaceId}/rooms/${roomId}/state`);\n    return response.state;\n  }\n\n  async getRoomInfo(workspaceId: string, roomId: string): Promise<RoomInfo> {\n    const response = await this.fetchApi<GetRoomResponse>(`/workspaces/${workspaceId}/rooms/${roomId}`);\n    return response.room;\n  }\n\n  // ============= WEBSOCKET CONNECTION =============\n\n  async connectToRoom(\n    workspaceId: string,\n    roomId: string,\n    role: ParticipantRole,\n    participantId?: string\n  ): Promise<boolean> {\n    if (this.connected) {\n      await this.disconnect();\n    }\n\n    this.workspaceId = workspaceId;\n    this.roomId = roomId;\n    this.role = role;\n    this.participantId = participantId || `${role}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Convert HTTP URL to WebSocket URL\n    const wsUrl = this.baseUrl\n      .replace(/^http/, 'ws')\n      .replace(/^https/, 'wss');\n    const wsEndpoint = `${wsUrl}/robotics/workspaces/${workspaceId}/rooms/${roomId}/ws`;\n\n    try {\n      this.websocket = new WebSocket(wsEndpoint);\n\n      // Set up WebSocket event handlers\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Connection timeout'));\n        }, this.options.timeout || 5000);\n\n        this.websocket!.onopen = () => {\n          clearTimeout(timeout);\n          this.sendJoinMessage();\n        };\n\n        this.websocket!.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            this.handleMessage(message);\n\n            // Handle initial connection responses\n            if (message.type === 'joined') {\n              this.connected = true;\n              this.onConnectedCallback?.();\n              this.emit('connected');\n              resolve(true);\n            } else if (message.type === 'error') {\n              this.handleError(message.message);\n              resolve(false);\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        this.websocket!.onerror = (error) => {\n          clearTimeout(timeout);\n          console.error('WebSocket error:', error);\n          this.handleError('WebSocket connection error');\n          reject(error);\n        };\n\n        this.websocket!.onclose = () => {\n          clearTimeout(timeout);\n          this.connected = false;\n          this.onDisconnectedCallback?.();\n          this.emit('disconnected');\n        };\n      });\n    } catch (error) {\n      console.error('Failed to connect to room:', error);\n      return false;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.close();\n    }\n\n    this.websocket = null;\n    this.connected = false;\n    this.workspaceId = null;\n    this.roomId = null;\n    this.role = null;\n    this.participantId = null;\n\n    this.onDisconnectedCallback?.();\n    this.emit('disconnected');\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected sendJoinMessage(): void {\n    if (!this.websocket || !this.participantId || !this.role) return;\n\n    const joinMessage: JoinMessage = {\n      participant_id: this.participantId,\n      role: this.role,\n    };\n\n    this.websocket.send(JSON.stringify(joinMessage));\n  }\n\n  protected handleMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'joined':\n        console.log(`Successfully joined room ${message.room_id} as ${message.role}`);\n        break;\n      case 'heartbeat_ack':\n        console.debug('Heartbeat acknowledged');\n        break;\n      case 'error':\n        this.handleError(message.message);\n        break;\n      default:\n        // Let subclasses handle specific message types\n        this.handleRoleSpecificMessage(message);\n    }\n  }\n\n  protected handleRoleSpecificMessage(message: WebSocketMessage): void {\n    // To be overridden by subclasses\n    this.emit('message', message);\n  }\n\n  protected handleError(errorMessage: string): void {\n    console.error('Client error:', errorMessage);\n    this.onErrorCallback?.(errorMessage);\n    this.emit('error', errorMessage);\n  }\n\n  // ============= UTILITY METHODS =============\n\n  async sendHeartbeat(): Promise<void> {\n    if (!this.connected || !this.websocket) return;\n\n    const message = { type: 'heartbeat' as const };\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  getConnectionInfo(): ConnectionInfo {\n    return {\n      connected: this.connected,\n      workspace_id: this.workspaceId,\n      room_id: this.roomId,\n      role: this.role,\n      participant_id: this.participantId,\n      base_url: this.baseUrl,\n    };\n  }\n\n  // ============= EVENT CALLBACK SETTERS =============\n\n  onError(callback: ErrorCallback): void {\n    this.onErrorCallback = callback;\n  }\n\n  onConnected(callback: ConnectedCallback): void {\n    this.onConnectedCallback = callback;\n  }\n\n  onDisconnected(callback: DisconnectedCallback): void {\n    this.onDisconnectedCallback = callback;\n  }\n\n  // ============= PRIVATE HELPERS =============\n\n  private async fetchApi<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.apiBase}${endpoint}`;\n    const response = await fetch(url, {\n      ...options,\n      signal: AbortSignal.timeout(this.options.timeout || 5000),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json() as Promise<T>;\n  }\n\n  // ============= WORKSPACE HELPERS =============\n\n  protected generateWorkspaceId(): string {\n    // Generate a UUID-like workspace ID\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n} ",
    "/**\n * Producer client for controlling robots in RobotHub TransportServer\n */\n\nimport { RoboticsClientCore } from './core.js';\nimport type {\n  JointData,\n  WebSocketMessage,\n  JointUpdateMessage,\n  ClientOptions,\n} from './types.js';\n\nexport class RoboticsProducer extends RoboticsClientCore {\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super(baseUrl, options);\n  }\n\n  // ============= PRODUCER CONNECTION =============\n\n  async connect(workspaceId: string, roomId: string, participantId?: string): Promise<boolean> {\n    return this.connectToRoom(workspaceId, roomId, 'producer', participantId);\n  }\n\n  // ============= PRODUCER METHODS =============\n\n  async sendJointUpdate(joints: JointData[]): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to send joint updates');\n    }\n\n    const message: JointUpdateMessage = {\n      type: 'joint_update',\n      data: joints,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  async sendStateSync(state: Record<string, number>): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to send state sync');\n    }\n\n    // Convert state object to joint updates format\n    const joints: JointData[] = Object.entries(state).map(([name, value]) => ({\n      name,\n      value,\n    }));\n\n    await this.sendJointUpdate(joints);\n  }\n\n  async sendEmergencyStop(reason = 'Emergency stop'): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to send emergency stop');\n    }\n\n    const message = {\n      type: 'emergency_stop' as const,\n      reason,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected override handleRoleSpecificMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'emergency_stop':\n        console.warn(`🚨 Emergency stop: ${message.reason || 'Unknown reason'}`);\n        this.handleError(`Emergency stop: ${message.reason || 'Unknown reason'}`);\n        break;\n      case 'error':\n        console.error(`Server error: ${message.message}`);\n        this.handleError(message.message);\n        break;\n      default:\n        console.warn(`Unknown message type for producer: ${message.type}`);\n    }\n  }\n\n  // ============= UTILITY METHODS =============\n\n  /**\n   * Create a room and automatically connect as producer\n   */\n  static async createAndConnect(\n    baseUrl = 'http://localhost:8000',\n    workspaceId?: string,\n    roomId?: string,\n    participantId?: string\n  ): Promise<RoboticsProducer> {\n    const producer = new RoboticsProducer(baseUrl);\n    \n    const roomData = await producer.createRoom(workspaceId, roomId);\n    const connected = await producer.connect(roomData.workspaceId, roomData.roomId, participantId);\n    \n    if (!connected) {\n      throw new Error('Failed to connect as producer');\n    }\n    \n    return producer;\n  }\n\n  /**\n   * Get the current room ID (useful when auto-created)\n   */\n  get currentRoomId(): string | null {\n    return this.roomId;\n  }\n} ",
    "/**\n * Consumer client for receiving robot commands in RobotHub TransportServer\n */\n\nimport { RoboticsClientCore } from './core.js';\nimport type {\n  WebSocketMessage,\n  JointUpdateMessage,\n  StateSyncMessage,\n  ClientOptions,\n  JointUpdateCallback,\n  StateSyncCallback,\n} from './types.js';\n\nexport class RoboticsConsumer extends RoboticsClientCore {\n  // Event callbacks\n  private onStateSyncCallback: StateSyncCallback | null = null;\n  private onJointUpdateCallback: JointUpdateCallback | null = null;\n\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super(baseUrl, options);\n  }\n\n  // ============= CONSUMER CONNECTION =============\n\n  async connect(workspaceId: string, roomId: string, participantId?: string): Promise<boolean> {\n    return this.connectToRoom(workspaceId, roomId, 'consumer', participantId);\n  }\n\n  // ============= CONSUMER METHODS =============\n\n  async getStateSyncAsync(): Promise<Record<string, number>> {\n    if (!this.workspaceId || !this.roomId) {\n      throw new Error('Must be connected to a room');\n    }\n\n    const state = await this.getRoomState(this.workspaceId, this.roomId);\n    return state.joints;\n  }\n\n  // ============= EVENT CALLBACKS =============\n\n  onStateSync(callback: StateSyncCallback): void {\n    this.onStateSyncCallback = callback;\n  }\n\n  onJointUpdate(callback: JointUpdateCallback): void {\n    this.onJointUpdateCallback = callback;\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected override handleRoleSpecificMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'state_sync':\n        this.handleStateSync(message as StateSyncMessage);\n        break;\n      case 'joint_update':\n        this.handleJointUpdate(message as JointUpdateMessage);\n        break;\n      case 'emergency_stop':\n        console.warn(`🚨 Emergency stop: ${message.reason || 'Unknown reason'}`);\n        this.handleError(`Emergency stop: ${message.reason || 'Unknown reason'}`);\n        break;\n      case 'error':\n        console.error(`Server error: ${message.message}`);\n        this.handleError(message.message);\n        break;\n      default:\n        console.warn(`Unknown message type for consumer: ${message.type}`);\n    }\n  }\n\n  private handleStateSync(message: StateSyncMessage): void {\n    if (this.onStateSyncCallback) {\n      this.onStateSyncCallback(message.data);\n    }\n    this.emit('stateSync', message.data);\n  }\n\n  private handleJointUpdate(message: JointUpdateMessage): void {\n    if (this.onJointUpdateCallback) {\n      this.onJointUpdateCallback(message.data);\n    }\n    this.emit('jointUpdate', message.data);\n  }\n\n  // ============= UTILITY METHODS =============\n\n  /**\n   * Create a consumer and automatically connect to a room\n   */\n  static async createAndConnect(\n    workspaceId: string,\n    roomId: string,\n    baseUrl = 'http://localhost:8000',\n    participantId?: string\n  ): Promise<RoboticsConsumer> {\n    const consumer = new RoboticsConsumer(baseUrl);\n    const connected = await consumer.connect(workspaceId, roomId, participantId);\n    \n    if (!connected) {\n      throw new Error('Failed to connect as consumer');\n    }\n    \n    return consumer;\n  }\n} ",
    "/**\n * Factory functions for creating RobotHub TransportServer robotics clients\n */\n\nimport { RoboticsProducer } from './producer.js';\nimport { RoboticsConsumer } from './consumer.js';\nimport type { ParticipantRole, ClientOptions } from './types.js';\n\n/**\n * Factory function to create the appropriate client based on role\n */\nexport function createClient(\n  role: ParticipantRole,\n  baseUrl = 'http://localhost:8000',\n  options: ClientOptions = {}\n): RoboticsProducer | RoboticsConsumer {\n  if (role === 'producer') {\n    return new RoboticsProducer(baseUrl, options);\n  }\n  if (role === 'consumer') {\n    return new RoboticsConsumer(baseUrl, options);\n  }\n  throw new Error(`Invalid role: ${role}. Must be 'producer' or 'consumer'`);\n}\n\n/**\n * Create and connect a producer client\n */\nexport async function createProducerClient(\n  baseUrl = 'http://localhost:8000',\n  workspaceId?: string,\n  roomId?: string,\n  participantId?: string,\n  options: ClientOptions = {}\n): Promise<RoboticsProducer> {\n  const producer = new RoboticsProducer(baseUrl, options);\n\n  const roomData = await producer.createRoom(workspaceId, roomId);\n  const connected = await producer.connect(roomData.workspaceId, roomData.roomId, participantId);\n\n  if (!connected) {\n    throw new Error('Failed to connect as producer');\n  }\n\n  return producer;\n}\n\n/**\n * Create and connect a consumer client\n */\nexport async function createConsumerClient(\n  workspaceId: string,\n  roomId: string,\n  baseUrl = 'http://localhost:8000',\n  participantId?: string,\n  options: ClientOptions = {}\n): Promise<RoboticsConsumer> {\n  const consumer = new RoboticsConsumer(baseUrl, options);\n  const connected = await consumer.connect(workspaceId, roomId, participantId);\n\n  if (!connected) {\n    throw new Error('Failed to connect as consumer');\n  }\n\n  return consumer;\n} ",
    "/**\n * Core video client for RobotHub TransportServer\n * Base class providing REST API, WebSocket, and WebRTC functionality\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type {\n  ParticipantRole,\n  RoomInfo,\n  RoomState,\n  ConnectionInfo,\n  WebSocketMessage,\n  JoinMessage,\n  ListRoomsResponse,\n  CreateRoomResponse,\n  GetRoomResponse,\n  GetRoomStateResponse,\n  DeleteRoomResponse,\n  WebRTCSignalResponse,\n  WebRTCSignalRequest,\n  ClientOptions,\n  WebRTCConfig,\n  WebRTCStats,\n  VideoConfig,\n  RecoveryConfig,\n  ErrorCallback,\n  ConnectedCallback,\n  DisconnectedCallback,\n} from './types.js';\n\nexport class VideoClientCore extends EventEmitter {\n  protected baseUrl: string;\n  protected apiBase: string;\n  protected websocket: WebSocket | null = null;\n  protected peerConnection: RTCPeerConnection | null = null;\n  protected localStream: MediaStream | null = null;\n  protected remoteStream: MediaStream | null = null;\n  protected workspaceId: string | null = null;\n  protected roomId: string | null = null;\n  protected role: ParticipantRole | null = null;\n  protected participantId: string | null = null;\n  protected connected = false;\n  protected options: ClientOptions;\n  protected webrtcConfig: WebRTCConfig;\n\n  // Event callbacks\n  protected onErrorCallback: ErrorCallback | null = null;\n  protected onConnectedCallback: ConnectedCallback | null = null;\n  protected onDisconnectedCallback: DisconnectedCallback | null = null;\n\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super();\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n    this.apiBase = `${this.baseUrl}/video`;\n    this.options = {\n      timeout: 5000,\n      reconnect_attempts: 3,\n      heartbeat_interval: 30000,\n      ...options,\n    };\n    this.webrtcConfig = {\n      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],\n      constraints: { \n        video: {\n          width: { ideal: 640 },\n          height: { ideal: 480 },\n          frameRate: { ideal: 30 }\n        }, \n        audio: false \n      },\n      bitrate: 1000000,\n      framerate: 30,\n      resolution: { width: 640, height: 480 },\n      codecPreferences: ['VP8', 'H264'],\n      ...this.options.webrtc_config,\n    };\n  }\n\n  // ============= REST API METHODS =============\n\n  async listRooms(workspaceId: string): Promise<RoomInfo[]> {\n    const response = await this.fetchApi<ListRoomsResponse>(`/workspaces/${workspaceId}/rooms`);\n    return response.rooms;\n  }\n\n  async createRoom(workspaceId?: string, roomId?: string, config?: VideoConfig, recoveryConfig?: RecoveryConfig): Promise<{ workspaceId: string; roomId: string }> {\n    // Generate workspace ID if not provided\n    const finalWorkspaceId = workspaceId || this.generateWorkspaceId();\n    \n    const payload = { \n      room_id: roomId, \n      workspace_id: finalWorkspaceId,\n      config, \n      recovery_config: recoveryConfig \n    };\n    const response = await this.fetchApi<CreateRoomResponse>(`/workspaces/${finalWorkspaceId}/rooms`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n    });\n    return { workspaceId: response.workspace_id, roomId: response.room_id };\n  }\n\n  async deleteRoom(workspaceId: string, roomId: string): Promise<boolean> {\n    try {\n      const response = await this.fetchApi<DeleteRoomResponse>(`/workspaces/${workspaceId}/rooms/${roomId}`, {\n        method: 'DELETE',\n      });\n      return response.success;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('404')) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  async getRoomState(workspaceId: string, roomId: string): Promise<RoomState> {\n    const response = await this.fetchApi<GetRoomStateResponse>(`/workspaces/${workspaceId}/rooms/${roomId}/state`);\n    return response.state;\n  }\n\n  async getRoomInfo(workspaceId: string, roomId: string): Promise<RoomInfo> {\n    const response = await this.fetchApi<GetRoomResponse>(`/workspaces/${workspaceId}/rooms/${roomId}`);\n    return response.room;\n  }\n\n  // ============= WEBRTC SIGNALING =============\n\n  async sendWebRTCSignal(workspaceId: string, roomId: string, clientId: string, message: RTCSessionDescriptionInit | RTCIceCandidateInit | Record<string, unknown>): Promise<WebRTCSignalResponse> {\n    const request: WebRTCSignalRequest = { client_id: clientId, message };\n    return this.fetchApi<WebRTCSignalResponse>(`/workspaces/${workspaceId}/rooms/${roomId}/webrtc/signal`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    });\n  }\n\n  // ============= WEBSOCKET CONNECTION =============\n\n  async connectToRoom(\n    workspaceId: string,\n    roomId: string,\n    role: ParticipantRole,\n    participantId?: string\n  ): Promise<boolean> {\n    if (this.connected) {\n      await this.disconnect();\n    }\n\n    this.workspaceId = workspaceId;\n    this.roomId = roomId;\n    this.role = role;\n    this.participantId = participantId || `${role}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Convert HTTP URL to WebSocket URL\n    const wsUrl = this.baseUrl\n      .replace(/^http/, 'ws')\n      .replace(/^https/, 'wss');\n    const wsEndpoint = `${wsUrl}/video/workspaces/${workspaceId}/rooms/${roomId}/ws`;\n\n    try {\n      this.websocket = new WebSocket(wsEndpoint);\n\n      // Set up WebSocket event handlers\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Connection timeout'));\n        }, this.options.timeout || 5000);\n\n        this.websocket!.onopen = () => {\n          clearTimeout(timeout);\n          this.sendJoinMessage();\n        };\n\n        this.websocket!.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            this.handleMessage(message);\n\n            // Handle initial connection responses\n            if (message.type === 'joined') {\n              this.connected = true;\n              this.onConnectedCallback?.();\n              this.emit('connected');\n              resolve(true);\n            } else if (message.type === 'error') {\n              this.handleError(message.message);\n              resolve(false);\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        this.websocket!.onerror = (error) => {\n          clearTimeout(timeout);\n          console.error('WebSocket error:', error);\n          this.handleError('WebSocket connection error');\n          reject(error);\n        };\n\n        this.websocket!.onclose = () => {\n          clearTimeout(timeout);\n          this.connected = false;\n          this.onDisconnectedCallback?.();\n          this.emit('disconnected');\n        };\n      });\n    } catch (error) {\n      console.error('Failed to connect to room:', error);\n      return false;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    // Close WebRTC connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    // Stop local streams\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n\n    // Close WebSocket\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.close();\n    }\n\n    this.websocket = null;\n    this.remoteStream = null;\n    this.connected = false;\n    this.workspaceId = null;\n    this.roomId = null;\n    this.role = null;\n    this.participantId = null;\n\n    this.onDisconnectedCallback?.();\n    this.emit('disconnected');\n  }\n\n  // ============= WEBRTC METHODS =============\n\n  createPeerConnection(): RTCPeerConnection {\n    const config: RTCConfiguration = {\n      iceServers: this.webrtcConfig.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ]\n    };\n\n    this.peerConnection = new RTCPeerConnection(config);\n\n    // Connection state changes\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection?.connectionState;\n      console.info(`🔌 WebRTC connection state: ${state}`);\n    };\n\n    // ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection?.iceConnectionState;\n      console.info(`🧊 ICE connection state: ${state}`);\n    };\n\n    // ICE candidate handling\n    this.peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent) => {\n      if (event.candidate && this.workspaceId && this.roomId && this.participantId) {\n        // Send ICE candidate via signaling\n        this.sendWebRTCSignal(this.workspaceId, this.roomId, this.participantId, {\n          type: 'ice',\n          candidate: event.candidate.toJSON()\n        } as Record<string, unknown>);\n      }\n    };\n\n    // Handle remote stream\n    this.peerConnection.ontrack = (event: RTCTrackEvent) => {\n      console.info('📺 Received remote track:', event.track.kind);\n      this.remoteStream = event.streams[0] || null;\n      this.emit('remoteStream', this.remoteStream);\n    };\n\n    return this.peerConnection;\n  }\n\n  async createOffer(): Promise<RTCSessionDescriptionInit> {\n    if (!this.peerConnection) {\n      throw new Error('Peer connection not created');\n    }\n\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n    \n    return offer;\n  }\n\n  async createAnswer(offer: RTCSessionDescriptionInit): Promise<RTCSessionDescriptionInit> {\n    if (!this.peerConnection) {\n      throw new Error('Peer connection not created');\n    }\n\n    await this.peerConnection.setRemoteDescription(offer);\n    const answer = await this.peerConnection.createAnswer();\n    await this.peerConnection.setLocalDescription(answer);\n    \n    return answer;\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    if (!this.peerConnection) {\n      throw new Error('Peer connection not created');\n    }\n\n    await this.peerConnection.setRemoteDescription(description);\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    if (!this.peerConnection) {\n      throw new Error('Peer connection not created');\n    }\n\n    await this.peerConnection.addIceCandidate(candidate);\n  }\n\n  // ============= MEDIA METHODS =============\n\n  async startProducing(constraints?: MediaStreamConstraints): Promise<MediaStream> {\n    const mediaConstraints = constraints || this.webrtcConfig.constraints;\n    \n    try {\n      this.localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\n      return this.localStream;\n    } catch (error) {\n      throw new Error(`Failed to start video production: ${error}`);\n    }\n  }\n\n  async startScreenShare(): Promise<MediaStream> {\n    try {\n      this.localStream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          width: this.webrtcConfig.resolution?.width || 1920,\n          height: this.webrtcConfig.resolution?.height || 1080,\n          frameRate: this.webrtcConfig.framerate || 30\n        },\n        audio: false\n      });\n      \n      return this.localStream;\n    } catch (error) {\n      throw new Error(`Failed to start screen share: ${error}`);\n    }\n  }\n\n  stopProducing(): void {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n\n  // ============= GETTERS =============\n\n  getLocalStream(): MediaStream | null {\n    return this.localStream;\n  }\n\n  getRemoteStream(): MediaStream | null {\n    return this.remoteStream;\n  }\n\n  getPeerConnection(): RTCPeerConnection | null {\n    return this.peerConnection;\n  }\n\n  async getStats(): Promise<WebRTCStats | null> {\n    if (!this.peerConnection) {\n      return null;\n    }\n\n    const stats = await this.peerConnection.getStats();\n    return this.extractVideoStats(stats);\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected sendJoinMessage(): void {\n    if (!this.websocket || !this.participantId || !this.role) return;\n\n    const joinMessage: JoinMessage = {\n      participant_id: this.participantId,\n      role: this.role,\n    };\n\n    this.websocket.send(JSON.stringify(joinMessage));\n  }\n\n  protected handleMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'joined':\n        console.log(`Successfully joined room ${message.room_id} as ${message.role}`);\n        break;\n      case 'heartbeat_ack':\n        console.debug('Heartbeat acknowledged');\n        break;\n      case 'error':\n        this.handleError(message.message);\n        break;\n      default:\n        // Let subclasses handle specific message types\n        this.handleRoleSpecificMessage(message);\n    }\n  }\n\n  protected handleRoleSpecificMessage(message: WebSocketMessage): void {\n    // To be overridden by subclasses\n    this.emit('message', message);\n  }\n\n  protected handleError(errorMessage: string): void {\n    console.error('Video client error:', errorMessage);\n    this.onErrorCallback?.(errorMessage);\n    this.emit('error', errorMessage);\n  }\n\n  // ============= UTILITY METHODS =============\n\n  async sendHeartbeat(): Promise<void> {\n    if (!this.connected || !this.websocket) return;\n\n    const message = { type: 'heartbeat' as const };\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  getConnectionInfo(): ConnectionInfo {\n    return {\n      connected: this.connected,\n      workspace_id: this.workspaceId,\n      room_id: this.roomId,\n      role: this.role,\n      participant_id: this.participantId,\n      base_url: this.baseUrl,\n    };\n  }\n\n  // ============= EVENT CALLBACK SETTERS =============\n\n  onError(callback: ErrorCallback): void {\n    this.onErrorCallback = callback;\n  }\n\n  onConnected(callback: ConnectedCallback): void {\n    this.onConnectedCallback = callback;\n  }\n\n  onDisconnected(callback: DisconnectedCallback): void {\n    this.onDisconnectedCallback = callback;\n  }\n\n  // ============= PRIVATE HELPERS =============\n\n  private async fetchApi<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.apiBase}${endpoint}`;\n    const response = await fetch(url, {\n      ...options,\n      signal: AbortSignal.timeout(this.options.timeout || 5000),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json() as Promise<T>;\n  }\n\n  private extractVideoStats(stats: RTCStatsReport): WebRTCStats | null {\n    let inboundVideoStats: RTCInboundRtpStreamStats | null = null;\n    let outboundVideoStats: RTCOutboundRtpStreamStats | null = null;\n\n    stats.forEach((report) => {\n      if (report.type === 'inbound-rtp' && 'kind' in report && report.kind === 'video') {\n        inboundVideoStats = report as RTCInboundRtpStreamStats;\n      } else if (report.type === 'outbound-rtp' && 'kind' in report && report.kind === 'video') {\n        outboundVideoStats = report as RTCOutboundRtpStreamStats;\n      }\n    });\n\n    // Handle inbound stats (consumer)\n    if (inboundVideoStats) {\n      return {\n        videoBitsPerSecond: (inboundVideoStats as any).bytesReceived || 0,\n        framesPerSecond: (inboundVideoStats as any).framesPerSecond || 0,\n        frameWidth: (inboundVideoStats as any).frameWidth || 0,\n        frameHeight: (inboundVideoStats as any).frameHeight || 0,\n        packetsLost: (inboundVideoStats as any).packetsLost || 0,\n        totalPackets: (inboundVideoStats as any).packetsReceived || (inboundVideoStats as any).framesDecoded || 0\n      };\n    }\n    \n    // Handle outbound stats (producer)\n    if (outboundVideoStats) {\n      return {\n        videoBitsPerSecond: (outboundVideoStats as any).bytesSent || 0,\n        framesPerSecond: (outboundVideoStats as any).framesPerSecond || 0,\n        frameWidth: (outboundVideoStats as any).frameWidth || 0,\n        frameHeight: (outboundVideoStats as any).frameHeight || 0,\n        packetsLost: (outboundVideoStats as any).packetsLost || 0,\n        totalPackets: (outboundVideoStats as any).packetsSent || (outboundVideoStats as any).framesSent || 0\n      };\n    }\n    \n    return null;\n  }\n\n  // ============= WORKSPACE HELPERS =============\n\n  protected generateWorkspaceId(): string {\n    // Generate a UUID-like workspace ID\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n} ",
    "/**\n * Producer client for video streaming in RobotHub TransportServer\n */\n\nimport { VideoClientCore } from './core.js';\nimport type {\n  WebSocketMessage,\n  VideoConfigUpdateMessage,\n  StreamStartedMessage,\n  StreamStoppedMessage,\n  StatusUpdateMessage,\n  StreamStatsMessage,\n  ClientOptions,\n  VideoConfig,\n  WebRTCAnswerMessage,\n  WebRTCIceMessage,\n} from './types.js';\n\nexport class VideoProducer extends VideoClientCore {\n  // Multiple peer connections - one per consumer\n  private consumerConnections: Map<string, RTCPeerConnection> = new Map();\n\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super(baseUrl, options);\n  }\n\n  // ============= PRODUCER CONNECTION =============\n\n  async connect(workspaceId: string, roomId: string, participantId?: string): Promise<boolean> {\n    const success = await this.connectToRoom(workspaceId, roomId, 'producer', participantId);\n    \n    if (success) {\n      // Listen for consumer join events to initiate WebRTC\n      this.on('consumer_joined', (consumerId: string) => {\n        console.info(`🎯 Consumer ${consumerId} joined, initiating WebRTC...`);\n        this.initiateWebRTCWithConsumer(consumerId);\n      });\n\n      // Also check for existing consumers and initiate connections after a delay\n      setTimeout(() => this.connectToExistingConsumers(), 1000);\n    }\n    \n    return success;\n  }\n\n  private async connectToExistingConsumers(): Promise<void> {\n    if (!this.workspaceId || !this.roomId) return;\n    \n    try {\n      const roomInfo = await this.getRoomInfo(this.workspaceId, this.roomId);\n      for (const consumerId of roomInfo.participants.consumers) {\n        if (!this.consumerConnections.has(consumerId)) {\n          console.info(`🔄 Connecting to existing consumer ${consumerId}`);\n          await this.initiateWebRTCWithConsumer(consumerId);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to connect to existing consumers:', error);\n    }\n  }\n\n  private createPeerConnectionForConsumer(consumerId: string): RTCPeerConnection {\n    const config: RTCConfiguration = {\n      iceServers: this.webrtcConfig.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ]\n    };\n\n    const peerConnection = new RTCPeerConnection(config);\n\n    // Add local stream tracks to this connection\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream!);\n      });\n    }\n\n    // Connection state changes\n    peerConnection.onconnectionstatechange = () => {\n      const state = peerConnection.connectionState;\n      console.info(`🔌 WebRTC connection state for ${consumerId}: ${state}`);\n      \n      if (state === 'failed' || state === 'disconnected') {\n        console.warn(`Connection to ${consumerId} failed, attempting restart...`);\n        setTimeout(() => this.restartConnectionToConsumer(consumerId), 2000);\n      }\n    };\n\n    // ICE connection state\n    peerConnection.oniceconnectionstatechange = () => {\n      const state = peerConnection.iceConnectionState;\n      console.info(`🧊 ICE connection state for ${consumerId}: ${state}`);\n    };\n\n    // ICE candidate handling for this specific consumer\n    peerConnection.onicecandidate = (event) => {\n      if (event.candidate && this.workspaceId && this.roomId && this.participantId) {\n        this.sendWebRTCSignal(this.workspaceId, this.roomId, this.participantId, {\n          type: 'ice',\n          candidate: event.candidate.toJSON(),\n          target_consumer: consumerId,\n        } as Record<string, unknown>);\n      }\n    };\n\n    // Store the connection\n    this.consumerConnections.set(consumerId, peerConnection);\n    \n    return peerConnection;\n  }\n\n  private async restartConnectionToConsumer(consumerId: string): Promise<void> {\n    console.info(`🔄 Restarting connection to consumer ${consumerId}`);\n    await this.initiateWebRTCWithConsumer(consumerId);\n  }\n\n  private handleConsumerLeft(consumerId: string): void {\n    const peerConnection = this.consumerConnections.get(consumerId);\n    if (peerConnection) {\n      peerConnection.close();\n      this.consumerConnections.delete(consumerId);\n      console.info(`🧹 Cleaned up peer connection for consumer ${consumerId}`);\n    }\n  }\n\n  private async restartConnectionsWithNewStream(stream: MediaStream): Promise<void> {\n    console.info('🔄 Restarting connections with new stream...', { streamId: stream.id });\n    // Close all existing connections\n    for (const entry of Array.from(this.consumerConnections.entries())) {\n      const [consumerId, peerConnection] = entry;\n      peerConnection.close();\n      console.info(`🧹 Closed existing connection to consumer ${consumerId}`);\n    }\n    this.consumerConnections.clear();\n\n    // Get current consumers and restart connections\n    try {\n      if (this.workspaceId && this.roomId) {\n        const roomInfo = await this.getRoomInfo(this.workspaceId, this.roomId);\n        for (const consumerId of roomInfo.participants.consumers) {\n          console.info(`🔄 Creating new connection to consumer ${consumerId}...`);\n          await this.initiateWebRTCWithConsumer(consumerId);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to restart connections:', error);\n    }\n  }\n\n  // ============= PRODUCER METHODS =============\n\n  async startCamera(constraints?: MediaStreamConstraints): Promise<MediaStream> {\n    if (!this.connected) {\n      throw new Error('Must be connected to start camera');\n    }\n\n    const stream = await this.startProducing(constraints);\n    \n    // Store the stream and restart connections with new tracks\n    this.localStream = stream;\n    await this.restartConnectionsWithNewStream(stream);\n\n    // Notify about stream start\n    this.notifyStreamStarted(stream);\n    \n    return stream;\n  }\n\n  override async startScreenShare(): Promise<MediaStream> {\n    if (!this.connected) {\n      throw new Error('Must be connected to start screen share');\n    }\n\n    const stream = await super.startScreenShare();\n    \n    // Store the stream and restart connections with new tracks\n    this.localStream = stream;\n    await this.restartConnectionsWithNewStream(stream);\n\n    // Notify about stream start\n    this.notifyStreamStarted(stream);\n    \n    return stream;\n  }\n\n  async stopStreaming(): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to stop streaming');\n    }\n    // Close all consumer connections\n    for (const consumerId of this.consumerConnections.keys()) {\n      const peerConnection = this.consumerConnections.get(consumerId);\n      peerConnection?.close();\n      console.info(`🧹 Closed connection to consumer ${consumerId}`);\n    }\n    this.consumerConnections.clear();\n\n    // Stop local stream\n    this.stopProducing();\n\n    // Notify about stream stop\n    this.notifyStreamStopped();\n  }\n\n  async updateVideoConfig(config: VideoConfig): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to update video config');\n    }\n\n    const message: VideoConfigUpdateMessage = {\n      type: 'video_config_update',\n      config,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  async sendEmergencyStop(reason = 'Emergency stop'): Promise<void> {\n    if (!this.connected || !this.websocket) {\n      throw new Error('Must be connected to send emergency stop');\n    }\n\n    const message = {\n      type: 'emergency_stop' as const,\n      reason,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  // ============= WEBRTC NEGOTIATION =============\n\n  async initiateWebRTCWithConsumer(consumerId: string): Promise<void> {\n    if (!this.workspaceId || !this.roomId || !this.participantId) {\n      console.warn('WebRTC not ready, skipping negotiation with consumer');\n      return;\n    }\n\n    // Clean up existing connection if any\n    if (this.consumerConnections.has(consumerId)) {\n      const existingConn = this.consumerConnections.get(consumerId);\n      existingConn?.close();\n      this.consumerConnections.delete(consumerId);\n    }\n\n    try {\n      console.info(`🔄 Creating WebRTC offer for consumer ${consumerId}...`);\n      \n      // Create a new peer connection specifically for this consumer\n      const peerConnection = this.createPeerConnectionForConsumer(consumerId);\n      \n      // Create offer with this consumer's peer connection\n      const offer = await peerConnection.createOffer();\n      await peerConnection.setLocalDescription(offer);\n      \n      console.info(`📤 Sending WebRTC offer to consumer ${consumerId}...`);\n      \n      // Send offer to server/consumer\n      await this.sendWebRTCSignal(this.workspaceId, this.roomId, this.participantId, {\n        type: 'offer',\n        sdp: offer.sdp,\n        target_consumer: consumerId,\n      } as Record<string, unknown>);\n      \n      console.info(`✅ WebRTC offer sent to consumer ${consumerId}`);\n    } catch (error) {\n      console.error(`Failed to initiate WebRTC with consumer ${consumerId}:`, error);\n    }\n  }\n\n  private async handleWebRTCAnswer(message: WebRTCAnswerMessage): Promise<void> {\n    try {\n      const consumerId = message.from_consumer;\n      console.info(`📥 Received WebRTC answer from consumer ${consumerId}`);\n      \n      const peerConnection = this.consumerConnections.get(consumerId);\n      if (!peerConnection) {\n        console.warn(`No peer connection found for consumer ${consumerId}`);\n        return;\n      }\n\n      // Set remote description on the correct peer connection\n      const answer = new RTCSessionDescription({\n        type: 'answer',\n        sdp: message.answer.sdp\n      });\n      \n      await peerConnection.setRemoteDescription(answer);\n      \n      console.info(`✅ WebRTC negotiation completed with consumer ${consumerId}`);\n    } catch (error) {\n      console.error(`Failed to handle WebRTC answer from ${message.from_consumer}:`, error);\n      this.handleError(`Failed to handle WebRTC answer: ${error}`);\n    }\n  }\n\n  private async handleWebRTCIce(message: WebRTCIceMessage): Promise<void> {\n    try {\n      const consumerId = message.from_consumer;\n      if (!consumerId) {\n        console.warn('No consumer ID in ICE message');\n        return;\n      }\n\n      const peerConnection = this.consumerConnections.get(consumerId);\n      if (!peerConnection) {\n        console.warn(`No peer connection found for consumer ${consumerId}`);\n        return;\n      }\n\n      console.info(`📥 Received WebRTC ICE from consumer ${consumerId}`);\n      \n      // Add ICE candidate to the correct peer connection\n      const candidate = new RTCIceCandidate(message.candidate);\n      await peerConnection.addIceCandidate(candidate);\n      \n      console.info(`✅ WebRTC ICE handled with consumer ${consumerId}`);\n    } catch (error) {\n      console.error(`Failed to handle WebRTC ICE from ${message.from_consumer}:`, error);\n      this.handleError(`Failed to handle WebRTC ICE: ${error}`);\n    }\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected override handleRoleSpecificMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'participant_joined':\n        // Check if this is a consumer joining\n        if (message.role === 'consumer' && message.participant_id !== this.participantId) {\n          console.info(`🎯 Consumer ${message.participant_id} joined room`);\n          this.emit('consumer_joined', message.participant_id);\n        }\n        break;\n      case 'participant_left':\n        // Check if this is a consumer leaving\n        if (message.role === 'consumer') {\n          console.info(`👋 Consumer ${message.participant_id} left room`);\n          this.handleConsumerLeft(message.participant_id);\n        }\n        break;\n      case 'webrtc_answer':\n        this.handleWebRTCAnswer(message as WebRTCAnswerMessage);\n        break;\n      case 'webrtc_ice':\n        this.handleWebRTCIce(message as WebRTCIceMessage);\n        break;\n      case 'status_update':\n        this.handleStatusUpdate(message as StatusUpdateMessage);\n        break;\n      case 'stream_stats':\n        this.handleStreamStats(message as StreamStatsMessage);\n        break;\n      case 'emergency_stop':\n        console.warn(`🚨 Emergency stop: ${message.reason || 'Unknown reason'}`);\n        this.handleError(`Emergency stop: ${message.reason || 'Unknown reason'}`);\n        break;\n      case 'error':\n        console.error(`Server error: ${message.message}`);\n        this.handleError(message.message);\n        break;\n      default:\n        console.warn(`Unknown message type for producer: ${message.type}`);\n    }\n  }\n\n  private handleStatusUpdate(message: StatusUpdateMessage): void {\n    console.info(`📊 Status update: ${message.status}`, message.data);\n    this.emit('statusUpdate', message.status, message.data);\n  }\n\n  private handleStreamStats(message: StreamStatsMessage): void {\n    console.debug(`📈 Stream stats:`, message.stats);\n    this.emit('streamStats', message.stats);\n  }\n\n  // ============= UTILITY METHODS =============\n\n  private async notifyStreamStarted(stream: MediaStream): Promise<void> {\n    if (!this.websocket) return;\n\n    const message: StreamStartedMessage = {\n      type: 'stream_started',\n      config: {\n        resolution: this.webrtcConfig.resolution,\n        framerate: this.webrtcConfig.framerate,\n        bitrate: this.webrtcConfig.bitrate,\n      },\n      participant_id: this.participantId!,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n    this.emit('streamStarted', stream);\n  }\n\n  private async notifyStreamStopped(): Promise<void> {\n    if (!this.websocket) return;\n\n    const message: StreamStoppedMessage = {\n      type: 'stream_stopped',\n      participant_id: this.participantId!,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.websocket.send(JSON.stringify(message));\n    this.emit('streamStopped');\n  }\n\n  /**\n   * Create a room and automatically connect as producer\n   */\n  static async createAndConnect(\n    baseUrl = 'http://localhost:8000',\n    workspaceId?: string,\n    roomId?: string,\n    participantId?: string\n  ): Promise<VideoProducer> {\n    const producer = new VideoProducer(baseUrl);\n    \n    const roomData = await producer.createRoom(workspaceId, roomId);\n    const connected = await producer.connect(roomData.workspaceId, roomData.roomId, participantId);\n    \n    if (!connected) {\n      throw new Error('Failed to connect as video producer');\n    }\n    \n    return producer;\n  }\n\n  /**\n   * Get the current room ID (useful when auto-created)\n   */\n  get currentRoomId(): string | null {\n    return this.roomId;\n  }\n} ",
    "/**\n * Consumer client for receiving video streams in RobotHub TransportServer\n */\n\nimport { VideoClientCore } from './core.js';\nimport type {\n  WebSocketMessage,\n  FrameUpdateMessage,\n  VideoConfigUpdateMessage,\n  StreamStartedMessage,\n  StreamStoppedMessage,\n  RecoveryTriggeredMessage,\n  StatusUpdateMessage,\n  StreamStatsMessage,\n  ClientOptions,\n  WebRTCStats,\n  FrameUpdateCallback,\n  VideoConfigUpdateCallback,\n  StreamStartedCallback,\n  StreamStoppedCallback,\n  RecoveryTriggeredCallback,\n  StatusUpdateCallback,\n  StreamStatsCallback,\n  WebRTCOfferMessage,\n  WebRTCIceMessage,\n} from './types.js';\n\nexport class VideoConsumer extends VideoClientCore {\n  // Event callbacks\n  private onFrameUpdateCallback: FrameUpdateCallback | null = null;\n  private onVideoConfigUpdateCallback: VideoConfigUpdateCallback | null = null;\n  private onStreamStartedCallback: StreamStartedCallback | null = null;\n  private onStreamStoppedCallback: StreamStoppedCallback | null = null;\n  private onRecoveryTriggeredCallback: RecoveryTriggeredCallback | null = null;\n  private onStatusUpdateCallback: StatusUpdateCallback | null = null;\n  private onStreamStatsCallback: StreamStatsCallback | null = null;\n\n  // ICE candidate queuing for proper timing\n  private iceCandidateQueue: { candidate: RTCIceCandidate; fromProducer: string }[] = [];\n  private hasRemoteDescription = false;\n\n  constructor(baseUrl = 'http://localhost:8000', options: ClientOptions = {}) {\n    super(baseUrl, options);\n  }\n\n  // ============= CONSUMER CONNECTION =============\n\n  async connect(workspaceId: string, roomId: string, participantId?: string): Promise<boolean> {\n    const connected = await this.connectToRoom(workspaceId, roomId, 'consumer', participantId);\n    \n    if (connected) {\n      // Create peer connection immediately so we're ready for WebRTC offers\n      console.info('🔧 Creating peer connection for consumer...');\n      await this.startReceiving();\n    }\n    \n    return connected;\n  }\n\n  // ============= CONSUMER METHODS =============\n\n  async startReceiving(): Promise<void> {\n    if (!this.connected) {\n      throw new Error('Must be connected to start receiving');\n    }\n\n    // Reset WebRTC state\n    this.hasRemoteDescription = false;\n    this.iceCandidateQueue = [];\n\n    // Create peer connection for receiving\n    this.createPeerConnection();\n    \n    // Set up to receive remote stream\n    if (this.peerConnection) {\n      this.peerConnection.ontrack = (event: RTCTrackEvent) => {\n        console.info('📺 Received remote track:', event.track.kind);\n        this.remoteStream = event.streams[0] || null;\n        this.emit('remoteStream', this.remoteStream);\n        this.emit('streamReceived', this.remoteStream);\n      };\n    }\n  }\n\n  async stopReceiving(): Promise<void> {\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    this.remoteStream = null;\n    this.emit('streamStopped');\n  }\n\n  // ============= WEBRTC NEGOTIATION =============\n\n  async handleWebRTCOffer(message: WebRTCOfferMessage): Promise<void> {\n    try {\n      console.info(`📥 Received WebRTC offer from producer ${message.from_producer}`);\n      \n      if (!this.peerConnection) {\n        console.warn('No peer connection available to handle offer');\n        return;\n      }\n\n      // Reset state for new offer\n      this.hasRemoteDescription = false;\n      this.iceCandidateQueue = [];\n\n      // Set remote description (the offer)\n      await this.setRemoteDescription(message.offer);\n      this.hasRemoteDescription = true;\n      \n      // Process any queued ICE candidates now that we have remote description\n      await this.processQueuedIceCandidates();\n      \n      // Create answer\n      const answer = await this.createAnswer(message.offer);\n      \n      console.info(`📤 Sending WebRTC answer to producer ${message.from_producer}`);\n      \n      // Send answer back through server to producer\n      if (this.workspaceId && this.roomId && this.participantId) {\n        await this.sendWebRTCSignal(this.workspaceId, this.roomId, this.participantId, {\n          type: 'answer',\n          sdp: answer.sdp,\n          target_producer: message.from_producer,\n        } as Record<string, unknown>);\n      }\n      \n      console.info('✅ WebRTC negotiation completed from consumer side');\n    } catch (error) {\n      console.error('Failed to handle WebRTC offer:', error);\n      this.handleError(`Failed to handle WebRTC offer: ${error}`);\n    }\n  }\n\n  private async handleWebRTCIce(message: WebRTCIceMessage): Promise<void> {\n    if (!this.peerConnection) {\n      console.warn('No peer connection available to handle ICE');\n      return;\n    }\n\n    try {\n      console.info(`📥 Received WebRTC ICE from producer ${message.from_producer}`);\n      \n      const candidate = new RTCIceCandidate(message.candidate);\n      \n      if (!this.hasRemoteDescription) {\n        // Queue ICE candidate until we have remote description\n        console.info(`🔄 Queuing ICE candidate from ${message.from_producer} (no remote description yet)`);\n        this.iceCandidateQueue.push({\n          candidate,\n          fromProducer: message.from_producer || 'unknown'\n        });\n        return;\n      }\n      \n      // Add ICE candidate to peer connection\n      await this.peerConnection.addIceCandidate(candidate);\n      \n      console.info(`✅ WebRTC ICE handled from producer ${message.from_producer}`);\n    } catch (error) {\n      console.error(`Failed to handle WebRTC ICE from ${message.from_producer}:`, error);\n      this.handleError(`Failed to handle WebRTC ICE: ${error}`);\n    }\n  }\n\n  private async processQueuedIceCandidates(): Promise<void> {\n    if (this.iceCandidateQueue.length === 0) {\n      return;\n    }\n\n    console.info(`🔄 Processing ${this.iceCandidateQueue.length} queued ICE candidates`);\n    \n    for (const { candidate, fromProducer } of this.iceCandidateQueue) {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.addIceCandidate(candidate);\n          console.info(`✅ Processed queued ICE candidate from ${fromProducer}`);\n        }\n      } catch (error) {\n        console.error(`Failed to process queued ICE candidate from ${fromProducer}:`, error);\n      }\n    }\n    \n    // Clear the queue\n    this.iceCandidateQueue = [];\n  }\n\n  // Override to add producer targeting for ICE candidates\n  override createPeerConnection(): RTCPeerConnection {\n    const config: RTCConfiguration = {\n      iceServers: this.webrtcConfig.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ]\n    };\n\n    this.peerConnection = new RTCPeerConnection(config);\n\n    // Connection state changes\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection?.connectionState;\n      console.info(`🔌 WebRTC connection state: ${state}`);\n    };\n\n    // ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection?.iceConnectionState;\n      console.info(`🧊 ICE connection state: ${state}`);\n    };\n\n    // ICE candidate handling - send to producer\n    this.peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent) => {\n      if (event.candidate && this.workspaceId && this.roomId && this.participantId) {\n        // Send ICE candidate to producer\n        this.sendIceCandidateToProducer(event.candidate);\n      }\n    };\n\n    // Handle remote stream\n    this.peerConnection.ontrack = (event: RTCTrackEvent) => {\n      console.info('📺 Received remote track:', event.track.kind);\n      this.remoteStream = event.streams[0] || null;\n      this.emit('remoteStream', this.remoteStream);\n      this.emit('streamReceived', this.remoteStream);\n    };\n\n    return this.peerConnection;\n  }\n\n  private async sendIceCandidateToProducer(candidate: RTCIceCandidate): Promise<void> {\n    if (!this.workspaceId || !this.roomId || !this.participantId) return;\n\n    try {\n      // Get room info to find the producer\n      const roomInfo = await this.getRoomInfo(this.workspaceId, this.roomId);\n      \n      if (roomInfo.participants.producer) {\n        await this.sendWebRTCSignal(this.workspaceId, this.roomId, this.participantId, {\n          type: 'ice',\n          candidate: candidate.toJSON(),\n          target_producer: roomInfo.participants.producer,\n        } as Record<string, unknown>);\n      }\n    } catch (error) {\n      console.error('Failed to send ICE candidate to producer:', error);\n    }\n  }\n\n  private async handleStreamStarted(message: StreamStartedMessage): Promise<void> {\n    if (this.onStreamStartedCallback) {\n      this.onStreamStartedCallback(message.config, message.participant_id);\n    }\n    this.emit('streamStarted', message.config, message.participant_id);\n\n    console.info(`🚀 Stream started by producer ${message.participant_id}, ready to receive video`);\n  }\n\n  // ============= EVENT CALLBACKS =============\n\n  onFrameUpdate(callback: FrameUpdateCallback): void {\n    this.onFrameUpdateCallback = callback;\n  }\n\n  onVideoConfigUpdate(callback: VideoConfigUpdateCallback): void {\n    this.onVideoConfigUpdateCallback = callback;\n  }\n\n  onStreamStarted(callback: StreamStartedCallback): void {\n    this.onStreamStartedCallback = callback;\n  }\n\n  onStreamStopped(callback: StreamStoppedCallback): void {\n    this.onStreamStoppedCallback = callback;\n  }\n\n  onRecoveryTriggered(callback: RecoveryTriggeredCallback): void {\n    this.onRecoveryTriggeredCallback = callback;\n  }\n\n  onStatusUpdate(callback: StatusUpdateCallback): void {\n    this.onStatusUpdateCallback = callback;\n  }\n\n  onStreamStats(callback: StreamStatsCallback): void {\n    this.onStreamStatsCallback = callback;\n  }\n\n  // ============= MESSAGE HANDLING =============\n\n  protected override handleRoleSpecificMessage(message: WebSocketMessage): void {\n    switch (message.type) {\n      case 'frame_update':\n        this.handleFrameUpdate(message as FrameUpdateMessage);\n        break;\n      case 'video_config_update':\n        this.handleVideoConfigUpdate(message as VideoConfigUpdateMessage);\n        break;\n      case 'stream_started':\n        this.handleStreamStarted(message as StreamStartedMessage);\n        break;\n      case 'stream_stopped':\n        this.handleStreamStopped(message as StreamStoppedMessage);\n        break;\n      case 'recovery_triggered':\n        this.handleRecoveryTriggered(message as RecoveryTriggeredMessage);\n        break;\n      case 'status_update':\n        this.handleStatusUpdate(message as StatusUpdateMessage);\n        break;\n      case 'stream_stats':\n        this.handleStreamStats(message as StreamStatsMessage);\n        break;\n      case 'participant_joined':\n        console.info(`📥 Participant joined: ${message.participant_id} as ${message.role}`);\n        break;\n      case 'participant_left':\n        console.info(`📤 Participant left: ${message.participant_id} (${message.role})`);\n        break;\n      case 'webrtc_offer':\n        this.handleWebRTCOffer(message as WebRTCOfferMessage);\n        break;\n      case 'webrtc_answer':\n        console.info('📨 Received WebRTC answer (consumer should not receive this)');\n        break;\n      case 'webrtc_ice':\n        this.handleWebRTCIce(message as WebRTCIceMessage);\n        break;\n      case 'emergency_stop':\n        console.warn(`🚨 Emergency stop: ${message.reason || 'Unknown reason'}`);\n        this.handleError(`Emergency stop: ${message.reason || 'Unknown reason'}`);\n        break;\n      case 'error':\n        console.error(`Server error: ${message.message}`);\n        this.handleError(message.message);\n        break;\n      default:\n        console.warn(`Unknown message type for consumer: ${message.type}`);\n    }\n  }\n\n  private handleFrameUpdate(message: FrameUpdateMessage): void {\n    if (this.onFrameUpdateCallback) {\n      const frameData = {\n        data: message.data,\n        metadata: message.metadata\n      };\n      this.onFrameUpdateCallback(frameData);\n    }\n    this.emit('frameUpdate', message.data);\n  }\n\n  private handleVideoConfigUpdate(message: VideoConfigUpdateMessage): void {\n    if (this.onVideoConfigUpdateCallback) {\n      this.onVideoConfigUpdateCallback(message.config);\n    }\n    this.emit('videoConfigUpdate', message.config);\n  }\n\n  private handleStreamStopped(message: StreamStoppedMessage): void {\n    if (this.onStreamStoppedCallback) {\n      this.onStreamStoppedCallback(message.participant_id, message.reason);\n    }\n    this.emit('streamStopped', message.participant_id, message.reason);\n  }\n\n  private handleRecoveryTriggered(message: RecoveryTriggeredMessage): void {\n    if (this.onRecoveryTriggeredCallback) {\n      this.onRecoveryTriggeredCallback(message.policy, message.reason);\n    }\n    this.emit('recoveryTriggered', message.policy, message.reason);\n  }\n\n  private handleStatusUpdate(message: StatusUpdateMessage): void {\n    if (this.onStatusUpdateCallback) {\n      this.onStatusUpdateCallback(message.status, message.data);\n    }\n    this.emit('statusUpdate', message.status, message.data);\n  }\n\n  private handleStreamStats(message: StreamStatsMessage): void {\n    if (this.onStreamStatsCallback) {\n      this.onStreamStatsCallback(message.stats);\n    }\n    this.emit('streamStats', message.stats);\n  }\n\n  // ============= UTILITY METHODS =============\n\n  /**\n   * Create a consumer and automatically connect to a room\n   */\n  static async createAndConnect(\n    workspaceId: string,\n    roomId: string,\n    baseUrl = 'http://localhost:8000',\n    participantId?: string\n  ): Promise<VideoConsumer> {\n    const consumer = new VideoConsumer(baseUrl);\n    const connected = await consumer.connect(workspaceId, roomId, participantId);\n    \n    if (!connected) {\n      throw new Error('Failed to connect as video consumer');\n    }\n    \n    return consumer;\n  }\n\n  /**\n   * Get the video element for displaying the remote stream\n   */\n  attachToVideoElement(videoElement: HTMLVideoElement): void {\n    if (this.remoteStream) {\n      videoElement.srcObject = this.remoteStream;\n    }\n    \n    // Listen for future stream updates\n    this.on('remoteStream', (stream: MediaStream) => {\n      videoElement.srcObject = stream;\n    });\n  }\n\n  /**\n   * Get current video statistics\n   */\n  async getVideoStats(): Promise<WebRTCStats | null> {\n    const stats = await this.getStats();\n    return stats;\n  }\n} ",
    "/**\n * Factory functions for creating RobotHub TransportServer video clients\n */\n\nimport { VideoProducer } from './producer.js';\nimport { VideoConsumer } from './consumer.js';\nimport type { ParticipantRole, ClientOptions } from './types.js';\n\n/**\n * Factory function to create the appropriate client based on role\n */\nexport function createClient(\n  role: ParticipantRole,\n  baseUrl = 'http://localhost:8000',\n  options: ClientOptions = {}\n): VideoProducer | VideoConsumer {\n  if (role === 'producer') {\n    return new VideoProducer(baseUrl, options);\n  }\n  if (role === 'consumer') {\n    return new VideoConsumer(baseUrl, options);\n  }\n  throw new Error(`Invalid role: ${role}. Must be 'producer' or 'consumer'`);\n}\n\n/**\n * Create and connect a producer client\n */\nexport async function createProducerClient(\n  baseUrl = 'http://localhost:8000',\n  workspaceId?: string,\n  roomId?: string,\n  participantId?: string,\n  options: ClientOptions = {}\n): Promise<VideoProducer> {\n  const producer = new VideoProducer(baseUrl, options);\n\n  const roomData = await producer.createRoom(workspaceId, roomId);\n  const connected = await producer.connect(roomData.workspaceId, roomData.roomId, participantId);\n\n  if (!connected) {\n    throw new Error('Failed to connect as video producer');\n  }\n\n  return producer;\n}\n\n/**\n * Create and connect a consumer client\n */\nexport async function createConsumerClient(\n  workspaceId: string,\n  roomId: string,\n  baseUrl = 'http://localhost:8000',\n  participantId?: string,\n  options: ClientOptions = {}\n): Promise<VideoConsumer> {\n  const consumer = new VideoConsumer(baseUrl, options);\n  const connected = await consumer.connect(workspaceId, roomId, participantId);\n\n  if (!connected) {\n    throw new Error('Failed to connect as video consumer');\n  }\n\n  return consumer;\n} ",
    "/**\n * RobotHub TransportServer Client Library - TypeScript/JavaScript\n * \n * Main entry point for the robotics client library.\n */\n\n// Re-export everything from robotics module\nexport * as robotics from './robotics/index.js';\nexport * as video from './video/index.js';\n\n// Version info\nexport const VERSION = '1.0.0';\n"
  ],
  "mappings": "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",
  "debugId": "DEA97CEBB2EADB0264756E2164756E21",
  "names": []
}